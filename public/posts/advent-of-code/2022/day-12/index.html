<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hill Climbing Algorithm | Gal.E</title><meta name=keywords content="Advent of Code,Go,Learning Go"><meta name=description content="Advent of Code day 12 solution"><meta name=author content="Gal Elmalah"><link rel=canonical href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/posts/advent-of-code/2022/day-12/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6cb923c56b6fe88a0f61e900dad874dd65bb59947d7a561900301be84cd05880.css integrity="sha256-bLkjxWtv6IoPYekA2th03WW7WZR9elYZADAb6EzQWIA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/favicon-32x32.png><link rel=apple-touch-icon href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/apple-touch-icon.png><link rel=mask-icon href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Hill Climbing Algorithm"><meta property="og:description" content="Advent of Code day 12 solution"><meta property="og:type" content="article"><meta property="og:url" content="https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/posts/advent-of-code/2022/day-12/"><meta property="og:image" content="https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/media/aoc.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-14T11:59:03+00:00"><meta property="article:modified_time" content="2022-12-14T11:59:03+00:00"><meta property="og:site_name" content="Gal.E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/media/aoc.jpg"><meta name=twitter:title content="Hill Climbing Algorithm"><meta name=twitter:description content="Advent of Code day 12 solution"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/posts/"},{"@type":"ListItem","position":2,"name":"Hill Climbing Algorithm","item":"https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/posts/advent-of-code/2022/day-12/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hill Climbing Algorithm","name":"Hill Climbing Algorithm","description":"Advent of Code day 12 solution","keywords":["Advent of Code","Go","Learning Go"],"articleBody":"Question\nWe are stuck at a river between two mountains, our communication device can’t get a decent singal but don’t worry THIS IS FINE!! we can get through this if we only find a high enough place to get a signal out\ncool cool cool, no doubt no doubt no doubt stay optimistic and don’t panic!!!\nThe one thing going for us at the moment is that we have a height map from our device, we just need to get to the heighst point and send a distrass signal\nOur map looks like this\n1 2 3 4 5 Sabqponm abcryxxl accszExk acctuvwj abdefghi Our current location is marked as S and our destination is marked as E We are also told that the height of each location is the ASCII value of each letter The value of S = a and E = z\nThis smells like a graph problem…\nParsing We could have use the structure of the input as is but I wanted to make it a bit more meaningful so we will parse it into a matrix of points! First, we will create a new Point struct\n1 2 3 4 5 6 7 8 9 10 11 type Point struct { i, j, v int } func (p *Point) id() string { return fmt.Sprintf(\"(%d,%d)\", p.i, p.j) } func newPoint(i, j, v int) *Point { return \u0026Point{i: i, j: j, v: v} } Each point location is kept with i and j, and the value is stored in v. We also create a struct method, id that we will probably need some time down the line\nAtough im by no means a go expert, having a new function for a struct seems like the standard. Probably because its a lot less verbose.\nNow lets change our input matrix into a matrix of Points\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func createPoint(i, j int, r rune) *Point { switch r { case 'S': return newPoint(i, j, 0) case 'E': return newPoint(i, j, int('z')-int('a')) default: return newPoint(i, j, int(r)-int('a')) } } func parse(raw string) (matrix [][]*Point, start *Point, dest *Point) { lines := strings.Split(string(raw), \"\\n\") matrix = make([][]*Point, len(lines)) for i := range matrix { matrix[i] = make([]*Point, len(lines[0])) rows := []*Point{} for j, c := range lines[i] { if c == 'S' { start = createPoint(i, j, c) } if c == 'E' { dest = createPoint(i, j, c) } rows = append(rows, createPoint(i, j, c)) } matrix[i] = rows } return matrix, start, dest } The first thing we do is to split our input on each \\n this will give us an array of lines AKA rows. We will split each of these “rows” to get each “cell” in our input For each cell we will create a new point and push it into the current row eventually we will end up with a matrix of points\nPart 1 We are asked to get from S to E with the least amount of step. Ohh and to make sure we won’t get to tired along the way we can only travel from p1 to p2 if the value in p2 is at most one higher than the value in p1.\nReading the first line, “with the least amount of step” this is a dead giveaway that we can and should use BFS\nSince we need a Queue to easily implement BFS and Go doesn’t have anything built in, we will need to create our own Queue first Create a new package named, well, queue and add the following logic and struct\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package queue import \"fmt\" type Queue[T comparable] struct { items []T } // Enqueue - Adds an item T to the Q func (q *Queue[T]) Enqueue(item T) { q.items = append(q.items, item) } // Dequeue - Removes an element from the Q - FIFO func (q *Queue[T]) Dequeue() T { if q.IsEmpty() { fmt.Println(\"Trying to Dequeue from an empty Queue\") } firstItem := q.items[0] q.items = q.items[1:] return firstItem } func (q *Queue[T]) Peek() T { return q.items[0] } func (q *Queue[T]) NumberOfItems() int { return len(q.items) } func (q *Queue[T]) IsEmpty() bool { return len(q.items) == 0 } There is nothing fancy here, just your regular Q… Armed with our new Queue we can start implemeting BFS The gist of BFS is\nStart from node X and push all its neighbors to the “processing” Queue In order to avoid duplicates in that Queue we will also maintain a Set of “seen” nodes, for that we will use our simple set from day 6 The last thing we need is to keep track of how we got to each node, this basically mean for point p1 who got it inside the Queue that is the currently processed point. Lets look at some code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 func BFS(graph [][]*Point, s *Point, destination *Point) int { // Creating a Queue Q := queue.Queue[*Point]{} // Adding the start node to the Queue Q.Enqueue(s) // Keeping track of who got us from into the Queue backTrack := map[string]string{} // Nodes we have seen seen := set.NewSimpleSet[string]() // Mark the starting node as seen to avoid pushing it into the Queue again seen.Add(s.id()) // We keep going over the \"graph\" while there are nodes in the Queue for !Q.IsEmpty() { // The node we are currently processing currentNode := Q.Dequeue() if currentNode == destination { // Yay we got to our destination, we can stop searching break } // Get all valid neighbors from our currently processes node // we will go over the implementation of get neighbors in a minute or two neighbors := getNeighbors(graph, currentNode) for _, v := range neighbors { // For each neighbor, if we haven't seen it before, do the following // 1. mark it as seen // 2. mark the node that got to him i.e our currently processed node // 3. push it to the Queue if !seen.Has(v.id()) { seen.Add(v.id()) backTrack[v.id()] = currentNode.id() Q.Enqueue(v) } } } // go over the route to the destiniton ndoe and count teh number of steps it took us return count(backTrack, destination.id()) } // simple recursive function that uses the node id to jump from p1 to p2 where p2 is the node that got p1 into the Queue func count(backTrack map[string]string, id string) int { v, ok := backTrack[id] if ok { return 1 + count(backTrack, v) } return 0 } func getNeighbors(graph [][]*Point, sink *Point) (neighbors []*Point) { // moves represent our up, right, down and left options moves := [][]int{{-1, 0}, {0, 1}, {1, 0}, {0, -1}} for _, move := range moves { // add the current move to the origin point di, dj := move[0]+sink.i, move[1]+sink.j // if the new indexes are in bound of our matrix/graph if di \u003e= 0 \u0026\u0026 di \u003c len(graph) \u0026\u0026 dj \u003e= 0 \u0026\u0026 dj \u003c len(graph[0]) { delta := graph[di][dj].v - sink.v // We were also told in the question that we need to make sure we make moves of at most 1 if delta \u003c= 1 { neighbors = append(neighbors, graph[di][dj]) } } } return neighbors } I tried making everything as clear as possible but if there is something you are struggling with, hit me up in the comment section\nOur final solution looks like this\n1 2 3 4 5 func Part1(raw string) int { graph, start, dest := parse(raw) steps := BFS(graph, start, dest) return steps } Part 2 Part 2 is were things gets intersting, we are now asked to find the shortest path to our destintion point but we can use every a in our map as a starting position and S We can take a naive approach here and see if it works, whats the naive approach you ask? Find all starting nodes and from each of those run our BFS and keep track of the minimum value This also means that we need to change our parsing function to collect all starting points\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // start is now an array of points func parse2(raw string) (matrix [][]*Point, start []*Point, dest *Point) { lines := strings.Split(string(raw), \"\\n\") matrix = make([][]*Point, len(lines)) for i := range matrix { matrix[i] = make([]*Point, len(lines[0])) rows := []*Point{} for j, c := range lines[i] { if c == 'S' || c == 'a' { start = append(start, createPoint(i, j, c)) } if c == 'E' { dest = createPoint(i, j, c) } rows = append(rows, createPoint(i, j, c)) } matrix[i] = rows } return matrix, start, dest } And our solution for part 2 will look like this\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func getMinValue(arr []int) (m int) { for i, e := range arr { if i == 0 || e \u003c m \u0026\u0026 e != 0 { m = e } } return md } func Part2NaiveApproach(raw string) int { graph, start, dest := parse2(raw) steps := []int{} for _, s := range start { res := BFS(graph, s, dest) if res \u003e 0 { steps = append(steps, res) } } return getMinValue(steps) } This works for the question input which really surprised me but it takes about 3 seconds to complete, we can do better!\nThere’s one thing that come to mind, why do we need to do a BFS from each node, can’t we just add all those starting nodes to our Queue as starting nodes? Well we can! its called multi-source BFS, I happen to know this approach from solving the monster question on CSES, give it a try.\nBefore we start tweaking things and trying new approaches, lets write some benchmarks so we can make sure what we are doing actually have an impact.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func BenchmarkPart1(b *testing.B) { input := util.ReadFile(\"./input.txt\") for n := 0; n \u003c b.N; n++ { Part1(input) } } func BenchmarkPart2NaiveApproach(b *testing.B) { input := util.ReadFile(\"./input.txt\") for n := 0; n \u003c b.N; n++ { Part2NaiveApproach(input) } } Run go test bench=. -count 2\n1 2 3 4 BenchmarkPart1-8 183 7225891 ns/op BenchmarkPart1-8 182 7127653 ns/op BenchmarkPart2NaiveApproach-8 1 1530454249 ns/op BenchmarkPart2NaiveApproach-8 1 1476970916 ns/op ophh… our naive approach is really really slow. it only run ones and took ~1530454249ns which is roughly 1.53 seconds compared to our part 1 results, this is just awful!\nOur Multi Source BFS approach is really similar to our original BFS but there are changes in first couple of lines\n1 2 3 4 5 6 7 8 9 10 11 // s is now an array of starting points func MultiSourceBFS(graph [][]*Point, s []*Point, destination *Point) int { Q := queue.Queue[*Point]{} seen := set.NewSimpleSet[string]() // for each starting point push int into the Queue and mark it as seen for _, v := range s { Q.Enqueue(v) seen.Add(v.id()) } ... ... See the complete code here\nLets write a benchmark for our multi source BFS approach\n1 2 3 4 5 6 7 func BenchmarkPart2MultiSourceBfs(b *testing.B) { input := util.ReadFile(\"./input.txt\") // run the Fib function b.N times for n := 0; n \u003c b.N; n++ { Part2MultiSourceBfs(input) } } Wow what a difference! Our Multi-source BFS run ~205 times and each run took only ~5841816ns which is rouhgly 0.0058 seconds! Thats about 274 times faster!\n1 2 3 4 5 6 BenchmarkPart1-8 184 7306437 ns/op BenchmarkPart1-8 181 6429481 ns/op BenchmarkPart2NaiveApproach-8 1 1475075477 ns/op BenchmarkPart2NaiveApproach-8 1 1450753723 ns/op BenchmarkPart2MultiSourceBfs-8 205 5841816 ns/op BenchmarkPart2MultiSourceBfs-8 204 5818908 ns/op So we had a fun graph problem and we have seen a few approaches to solve it, what a fun day! hopefully you learned something new from this day post.\nAs a final note Ill leave you all with a question, is there an even better way of doing what we just did? Can we perhaps change our logic a bit and start from a different node and get our desired answer in an even more efficient way? Let me know in the comments if you have any ideas :)\nThat’s it for today, see you tomorrow ⭐️\nYou can find the complete code here Thanks for reading!\n","wordCount":"2173","inLanguage":"en","image":"https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/media/aoc.jpg","datePublished":"2022-12-14T11:59:03Z","dateModified":"2022-12-14T11:59:03Z","author":{"@type":"Person","name":"Gal Elmalah"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/posts/advent-of-code/2022/day-12/"},"publisher":{"@type":"Organization","name":"Gal.E","logo":{"@type":"ImageObject","url":"https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/ accesskey=h title="Home (Alt + H)"><img src=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/>Home</a>&nbsp;»&nbsp;<a href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/posts/>Posts</a></div><h1 class=post-title>Hill Climbing Algorithm</h1><div class=post-description>Advent of Code day 12 solution</div><div class=post-meta><span title='2022-12-14 11:59:03 +0000 +0000'>December 14, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2173 words&nbsp;·&nbsp;Gal Elmalah&nbsp;|&nbsp;<a href=https://github.com/galElmalah/personal-blog/tree/master/content/posts/advent-of-code/2022/day-12/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/media/aoc.jpg alt=hills></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#parsing aria-label=Parsing>Parsing</a></li><li><a href=#part-1 aria-label="Part 1">Part 1</a></li><li><a href=#part-2 aria-label="Part 2">Part 2</a></li></ul></div></details></div><div class=post-content><p><a href=https://adventofcode.com/2022/day/12>Question</a></p><p>We are stuck at a river between two mountains, our communication device can&rsquo;t get a decent singal but don&rsquo;t worry
<strong>THIS IS FINE!!</strong> we can get through this if we only find a high enough place to get a signal out</p><p>cool cool cool, no doubt no doubt no doubt stay optimistic and don&rsquo;t panic!!!</p><p>The one thing going for us at the moment is that we have a height map from our device, we just need to get to the heighst point and send a distrass signal</p><p>Our map looks like this</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Sabqponm
</span></span><span class=line><span class=cl>abcryxxl
</span></span><span class=line><span class=cl>accszExk
</span></span><span class=line><span class=cl>acctuvwj
</span></span><span class=line><span class=cl>abdefghi
</span></span></code></pre></td></tr></table></div></div><p>Our current location is marked as <strong>S</strong> and our destination is marked as <strong>E</strong>
We are also told that the height of each location is the ASCII value of each letter
The value of <strong>S = a</strong> and <strong>E = z</strong></p><p>This smells like a graph problem&mldr;</p><h3 id=parsing>Parsing<a hidden class=anchor aria-hidden=true href=#parsing>#</a></h3><p>We could have use the structure of the input as is but I wanted to make it a bit more meaningful so we will parse it into a matrix of points!
First, we will create a new <code>Point</code> struct</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Point</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>v</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>p</span> <span class=o>*</span><span class=nx>Point</span><span class=p>)</span> <span class=nf>id</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;(%d,%d)&#34;</span><span class=p>,</span> <span class=nx>p</span><span class=p>.</span><span class=nx>i</span><span class=p>,</span> <span class=nx>p</span><span class=p>.</span><span class=nx>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>newPoint</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>v</span> <span class=kt>int</span><span class=p>)</span> <span class=o>*</span><span class=nx>Point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>Point</span><span class=p>{</span><span class=nx>i</span><span class=p>:</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>:</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>v</span><span class=p>:</span> <span class=nx>v</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Each point location is kept with <code>i</code> and <code>j</code>, and the value is stored in <code>v</code>.
We also create a struct method, <code>id</code> that we will probably need some time down the line</p><blockquote><p>Atough im by no means a go expert, having a new function for a struct seems like the standard. Probably because its a lot less verbose.</p></blockquote><p>Now lets change our input matrix into a matrix of <code>Point</code>s</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>createPoint</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>r</span> <span class=kt>rune</span><span class=p>)</span> <span class=o>*</span><span class=nx>Point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=nx>r</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=sc>&#39;S&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nf>newPoint</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=sc>&#39;E&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nf>newPoint</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=sc>&#39;z&#39;</span><span class=p>)</span><span class=o>-</span><span class=nb>int</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nf>newPoint</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>r</span><span class=p>)</span><span class=o>-</span><span class=nb>int</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>parse</span><span class=p>(</span><span class=nx>raw</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>matrix</span> <span class=p>[][]</span><span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nx>start</span> <span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nx>dest</span> <span class=o>*</span><span class=nx>Point</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>lines</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>raw</span><span class=p>),</span> <span class=s>&#34;\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>matrix</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([][]</span><span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>lines</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>matrix</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>matrix</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>lines</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>		<span class=nx>rows</span> <span class=o>:=</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Point</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>c</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>lines</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>c</span> <span class=o>==</span> <span class=sc>&#39;S&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>start</span> <span class=p>=</span> <span class=nf>createPoint</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>c</span> <span class=o>==</span> <span class=sc>&#39;E&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>dest</span> <span class=p>=</span> <span class=nf>createPoint</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>rows</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>rows</span><span class=p>,</span> <span class=nf>createPoint</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>matrix</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>rows</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>matrix</span><span class=p>,</span> <span class=nx>start</span><span class=p>,</span> <span class=nx>dest</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The first thing we do is to split our input on each <code>\n</code> this will give us an array of lines AKA rows.
We will split each of these &ldquo;rows&rdquo; to get each &ldquo;cell&rdquo; in our input
For each cell we will create a new point and push it into the current row
eventually we will end up with a matrix of points</p><h3 id=part-1>Part 1<a hidden class=anchor aria-hidden=true href=#part-1>#</a></h3><p>We are asked to get from <code>S</code> to <code>E</code> with the least amount of step.
Ohh and to make sure we won&rsquo;t get to tired along the way we can only travel from <code>p1</code> to <code>p2</code> if the value in <code>p2</code> is <strong>at most one higher</strong> than the value in <code>p1</code>.</p><p>Reading the first line, &ldquo;with the least amount of step&rdquo; this is a dead giveaway that we can and should use <a href=https://en.wikipedia.org/wiki/Breadth-first_search>BFS</a></p><p>Since we need a <a href=https://www.geeksforgeeks.org/queue-data-structure/>Queue</a> to easily implement BFS and Go doesn&rsquo;t have anything built in, we will need to create our own Queue first
Create a new package named, well, <code>queue</code> and add the following logic and struct</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>queue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Queue</span><span class=p>[</span><span class=nx>T</span> <span class=nx>comparable</span><span class=p>]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>items</span> <span class=p>[]</span><span class=nx>T</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Enqueue - Adds an item T to the Q
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=o>*</span><span class=nx>Queue</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Enqueue</span><span class=p>(</span><span class=nx>item</span> <span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>q</span><span class=p>.</span><span class=nx>items</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>q</span><span class=p>.</span><span class=nx>items</span><span class=p>,</span> <span class=nx>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Dequeue - Removes an element from the Q - FIFO
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=o>*</span><span class=nx>Queue</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Dequeue</span><span class=p>()</span> <span class=nx>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>q</span><span class=p>.</span><span class=nf>IsEmpty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Trying to Dequeue from an empty Queue&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>firstItem</span> <span class=o>:=</span> <span class=nx>q</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=nx>q</span><span class=p>.</span><span class=nx>items</span> <span class=p>=</span> <span class=nx>q</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>firstItem</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=o>*</span><span class=nx>Queue</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>Peek</span><span class=p>()</span> <span class=nx>T</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>q</span><span class=p>.</span><span class=nx>items</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=o>*</span><span class=nx>Queue</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>NumberOfItems</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>q</span><span class=p>.</span><span class=nx>items</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>q</span> <span class=o>*</span><span class=nx>Queue</span><span class=p>[</span><span class=nx>T</span><span class=p>])</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=nx>q</span><span class=p>.</span><span class=nx>items</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>There is nothing fancy here, just your regular Q&mldr;
Armed with our new Queue we can start implemeting BFS
The gist of BFS is</p><ol><li>Start from node X and push all its neighbors to the &ldquo;processing&rdquo; Queue</li><li>In order to avoid duplicates in that Queue we will also maintain a Set of &ldquo;seen&rdquo; nodes, for that we will use our simple set from <a href=https://dev.to/galelmalah/aoc-day-6-tuning-trouble-1d9f>day 6</a></li><li>The last thing we need is to keep track of how we got to each node, this basically mean for point <code>p1</code> who got it inside the Queue that is the currently processed point.
Lets look at some code</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BFS</span><span class=p>(</span><span class=nx>graph</span> <span class=p>[][]</span><span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nx>s</span> <span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nx>destination</span> <span class=o>*</span><span class=nx>Point</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Creating a Queue
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>Q</span> <span class=o>:=</span> <span class=nx>queue</span><span class=p>.</span><span class=nx>Queue</span><span class=p>[</span><span class=o>*</span><span class=nx>Point</span><span class=p>]{}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Adding the start node to the Queue
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>Q</span><span class=p>.</span><span class=nf>Enqueue</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Keeping track of who got us from into the Queue
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>backTrack</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Nodes we have seen
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>seen</span> <span class=o>:=</span> <span class=nx>set</span><span class=p>.</span><span class=nx>NewSimpleSet</span><span class=p>[</span><span class=kt>string</span><span class=p>]()</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Mark the starting node as seen to avoid pushing it into the Queue again
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>seen</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nf>id</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=c1>// We keep going over the &#34;graph&#34; while there are nodes in the Queue
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>!</span><span class=nx>Q</span><span class=p>.</span><span class=nf>IsEmpty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// The node we are currently processing
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>currentNode</span> <span class=o>:=</span> <span class=nx>Q</span><span class=p>.</span><span class=nf>Dequeue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>currentNode</span> <span class=o>==</span> <span class=nx>destination</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Yay we got to our destination, we can stop searching
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Get all valid neighbors from our currently processes node
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// we will go over the implementation of get neighbors in a minute or two
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>neighbors</span> <span class=o>:=</span> <span class=nf>getNeighbors</span><span class=p>(</span><span class=nx>graph</span><span class=p>,</span> <span class=nx>currentNode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>neighbors</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// For each neighbor, if we haven&#39;t seen it before, do the following
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 1. mark it as seen
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 2. mark the node that got to him i.e our currently processed node
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// 3. push it to the Queue
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=p>!</span><span class=nx>seen</span><span class=p>.</span><span class=nf>Has</span><span class=p>(</span><span class=nx>v</span><span class=p>.</span><span class=nf>id</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>seen</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>v</span><span class=p>.</span><span class=nf>id</span><span class=p>())</span>
</span></span><span class=line><span class=cl>				<span class=nx>backTrack</span><span class=p>[</span><span class=nx>v</span><span class=p>.</span><span class=nf>id</span><span class=p>()]</span> <span class=p>=</span> <span class=nx>currentNode</span><span class=p>.</span><span class=nf>id</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=nx>Q</span><span class=p>.</span><span class=nf>Enqueue</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// go over the route to the destiniton ndoe and count teh number of steps it took us
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nf>count</span><span class=p>(</span><span class=nx>backTrack</span><span class=p>,</span> <span class=nx>destination</span><span class=p>.</span><span class=nf>id</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// simple recursive function that uses the node id to jump from p1 to p2 where p2 is the node that got p1 into the Queue
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>count</span><span class=p>(</span><span class=nx>backTrack</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=nx>id</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>v</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>backTrack</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>1</span> <span class=o>+</span> <span class=nf>count</span><span class=p>(</span><span class=nx>backTrack</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getNeighbors</span><span class=p>(</span><span class=nx>graph</span> <span class=p>[][]</span><span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nx>sink</span> <span class=o>*</span><span class=nx>Point</span><span class=p>)</span> <span class=p>(</span><span class=nx>neighbors</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Point</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// moves represent our up, right, down and left options
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>moves</span> <span class=o>:=</span> <span class=p>[][]</span><span class=kt>int</span><span class=p>{{</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>},</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>move</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>moves</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// add the current move to the origin point
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>di</span><span class=p>,</span> <span class=nx>dj</span> <span class=o>:=</span> <span class=nx>move</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>+</span><span class=nx>sink</span><span class=p>.</span><span class=nx>i</span><span class=p>,</span> <span class=nx>move</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>+</span><span class=nx>sink</span><span class=p>.</span><span class=nx>j</span>
</span></span><span class=line><span class=cl>    <span class=c1>// if the new indexes are in bound of our matrix/graph
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>di</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>di</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>graph</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nx>dj</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>dj</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>graph</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>delta</span> <span class=o>:=</span> <span class=nx>graph</span><span class=p>[</span><span class=nx>di</span><span class=p>][</span><span class=nx>dj</span><span class=p>].</span><span class=nx>v</span> <span class=o>-</span> <span class=nx>sink</span><span class=p>.</span><span class=nx>v</span>
</span></span><span class=line><span class=cl>      <span class=c1>// We were also told in the question that we need to make sure we make moves of at most 1
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=nx>delta</span> <span class=o>&lt;=</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>neighbors</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>neighbors</span><span class=p>,</span> <span class=nx>graph</span><span class=p>[</span><span class=nx>di</span><span class=p>][</span><span class=nx>dj</span><span class=p>])</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>neighbors</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>I tried making everything as clear as possible but if there is something you are struggling with, hit me up in the comment section</p><p>Our final solution looks like this</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Part1</span><span class=p>(</span><span class=nx>raw</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>graph</span><span class=p>,</span> <span class=nx>start</span><span class=p>,</span> <span class=nx>dest</span> <span class=o>:=</span> <span class=nf>parse</span><span class=p>(</span><span class=nx>raw</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>steps</span> <span class=o>:=</span> <span class=nf>BFS</span><span class=p>(</span><span class=nx>graph</span><span class=p>,</span> <span class=nx>start</span><span class=p>,</span> <span class=nx>dest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>steps</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=part-2>Part 2<a hidden class=anchor aria-hidden=true href=#part-2>#</a></h3><p>Part 2 is were things gets intersting, we are now asked to find the shortest path to our destintion point but we can use every <code>a</code> in our map as a starting position and <code>S</code>
We can take a naive approach here and see if it works, whats the naive approach you ask?
Find all starting nodes and from each of those run our BFS and keep track of the minimum value
This also means that we need to change our parsing function to collect all starting points</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// start is now an array of points
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>parse2</span><span class=p>(</span><span class=nx>raw</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>matrix</span> <span class=p>[][]</span><span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nx>start</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nx>dest</span> <span class=o>*</span><span class=nx>Point</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>lines</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>raw</span><span class=p>),</span> <span class=s>&#34;\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>matrix</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([][]</span><span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>lines</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>matrix</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>matrix</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>lines</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>		<span class=nx>rows</span> <span class=o>:=</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Point</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>c</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>lines</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>c</span> <span class=o>==</span> <span class=sc>&#39;S&#39;</span> <span class=o>||</span> <span class=nx>c</span> <span class=o>==</span> <span class=sc>&#39;a&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>start</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>start</span><span class=p>,</span> <span class=nf>createPoint</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>c</span> <span class=o>==</span> <span class=sc>&#39;E&#39;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>dest</span> <span class=p>=</span> <span class=nf>createPoint</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>rows</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>rows</span><span class=p>,</span> <span class=nf>createPoint</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=nx>j</span><span class=p>,</span> <span class=nx>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>matrix</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>rows</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>matrix</span><span class=p>,</span> <span class=nx>start</span><span class=p>,</span> <span class=nx>dest</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>And our solution for part 2 will look like this</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getMinValue</span><span class=p>(</span><span class=nx>arr</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>m</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>e</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>arr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>e</span> <span class=p>&lt;</span> <span class=nx>m</span> <span class=o>&amp;&amp;</span> <span class=nx>e</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>m</span> <span class=p>=</span> <span class=nx>e</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>md</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Part2NaiveApproach</span><span class=p>(</span><span class=nx>raw</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>graph</span><span class=p>,</span> <span class=nx>start</span><span class=p>,</span> <span class=nx>dest</span> <span class=o>:=</span> <span class=nf>parse2</span><span class=p>(</span><span class=nx>raw</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>steps</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>s</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>start</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>res</span> <span class=o>:=</span> <span class=nf>BFS</span><span class=p>(</span><span class=nx>graph</span><span class=p>,</span> <span class=nx>s</span><span class=p>,</span> <span class=nx>dest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>res</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>steps</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>steps</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>getMinValue</span><span class=p>(</span><span class=nx>steps</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This works for the question input which really surprised me but it takes about 3 seconds to complete, we can do better!</p><p>There&rsquo;s one thing that come to mind, why do we need to do a BFS from each node, can&rsquo;t we just add all those starting nodes to our Queue as starting nodes?
Well we can! its called <a href=https://www.geeksforgeeks.org/multi-source-shortest-path-in-unweighted-graph/>multi-source BFS</a>,
I happen to know this approach from solving the monster question on CSES, <a href=https://cses.fi/problemset/task/1194>give it a try</a>.</p><p>Before we start tweaking things and trying new approaches, lets write some benchmarks so we can make sure what we are doing actually have an impact.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkPart1</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>input</span> <span class=o>:=</span> <span class=nx>util</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=s>&#34;./input.txt&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>n</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>Part1</span><span class=p>(</span><span class=nx>input</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkPart2NaiveApproach</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>input</span> <span class=o>:=</span> <span class=nx>util</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=s>&#34;./input.txt&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>n</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>Part2NaiveApproach</span><span class=p>(</span><span class=nx>input</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Run <code>go test bench=. -count 2</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>BenchmarkPart1-8                             183           7225891 ns/op
</span></span><span class=line><span class=cl>BenchmarkPart1-8                             182           7127653 ns/op
</span></span><span class=line><span class=cl>BenchmarkPart2NaiveApproach-8                  1        1530454249 ns/op
</span></span><span class=line><span class=cl>BenchmarkPart2NaiveApproach-8                  1        1476970916 ns/op
</span></span></code></pre></td></tr></table></div></div><p>ophh&mldr; our naive approach is really really slow. it only run ones and took ~<code>1530454249ns</code> which is roughly 1.53 seconds
compared to our part 1 results, this is just awful!</p><p>Our Multi Source BFS approach is really similar to our original BFS but there are changes in first couple of lines</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// s is now an array of starting points
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>MultiSourceBFS</span><span class=p>(</span><span class=nx>graph</span> <span class=p>[][]</span><span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nx>s</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Point</span><span class=p>,</span> <span class=nx>destination</span> <span class=o>*</span><span class=nx>Point</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Q</span> <span class=o>:=</span> <span class=nx>queue</span><span class=p>.</span><span class=nx>Queue</span><span class=p>[</span><span class=o>*</span><span class=nx>Point</span><span class=p>]{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>seen</span> <span class=o>:=</span> <span class=nx>set</span><span class=p>.</span><span class=nx>NewSimpleSet</span><span class=p>[</span><span class=kt>string</span><span class=p>]()</span>
</span></span><span class=line><span class=cl>  <span class=c1>// for each starting point push int into the Queue and mark it as seen
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Q</span><span class=p>.</span><span class=nf>Enqueue</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>seen</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=nx>v</span><span class=p>.</span><span class=nf>id</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span></code></pre></td></tr></table></div></div><p>See the complete code <a href=https://github.com/galElmalah/aoc-2022/blob/master/day-12/main.go#L119>here</a></p><p>Lets write a benchmark for our multi source BFS approach</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkPart2MultiSourceBfs</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>input</span> <span class=o>:=</span> <span class=nx>util</span><span class=p>.</span><span class=nf>ReadFile</span><span class=p>(</span><span class=s>&#34;./input.txt&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// run the Fib function b.N times
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>n</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>Part2MultiSourceBfs</span><span class=p>(</span><span class=nx>input</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Wow what a difference! Our Multi-source BFS run ~205 times and each run took only <code>~5841816ns</code> which is rouhgly 0.0058 seconds!
Thats about 274 times faster!</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>BenchmarkPart1-8                             184           7306437 ns/op
</span></span><span class=line><span class=cl>BenchmarkPart1-8                             181           6429481 ns/op
</span></span><span class=line><span class=cl>BenchmarkPart2NaiveApproach-8                  1        1475075477 ns/op
</span></span><span class=line><span class=cl>BenchmarkPart2NaiveApproach-8                  1        1450753723 ns/op
</span></span><span class=line><span class=cl>BenchmarkPart2MultiSourceBfs-8               205           5841816 ns/op
</span></span><span class=line><span class=cl>BenchmarkPart2MultiSourceBfs-8               204           5818908 ns/op
</span></span></code></pre></td></tr></table></div></div><p>So we had a fun graph problem and we have seen a few approaches to solve it, what a fun day!
hopefully you learned something new from this day post.</p><p>As a final note Ill leave you all with a question, is there an even better way of doing what we just did?
Can we perhaps change our logic a bit and start from a different node and get our desired answer in an even more efficient way?
Let me know in the comments if you have any ideas :)</p><hr><p>That&rsquo;s it for today, see you tomorrow ⭐️</p><p>You can find the complete code <a href=https://github.com/galElmalah/aoc-2022/tree/master/day-12>here</a>
Thanks for reading!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/tags/advent-of-code/>Advent of Code</a></li><li><a href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/tags/go/>Go</a></li><li><a href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/tags/learning-go/>Learning Go</a></li></ul><nav class=paginav><a class=next href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/posts/advent-of-code/2022/day-10/><span class=title>Next »</span><br><span>Cathode-Ray Tube</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Hill Climbing Algorithm on twitter" href="https://twitter.com/intent/tweet/?text=Hill%20Climbing%20Algorithm&url=https%3a%2f%2fpersonal-blog-9z4kmk1ax-galelmalah.vercel.app%2fposts%2fadvent-of-code%2f2022%2fday-12%2f&hashtags=AdventofCode%2cGo%2cLearningGo"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hill Climbing Algorithm on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fpersonal-blog-9z4kmk1ax-galelmalah.vercel.app%2fposts%2fadvent-of-code%2f2022%2fday-12%2f&title=Hill%20Climbing%20Algorithm&summary=Hill%20Climbing%20Algorithm&source=https%3a%2f%2fpersonal-blog-9z4kmk1ax-galelmalah.vercel.app%2fposts%2fadvent-of-code%2f2022%2fday-12%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hill Climbing Algorithm on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fpersonal-blog-9z4kmk1ax-galelmalah.vercel.app%2fposts%2fadvent-of-code%2f2022%2fday-12%2f&title=Hill%20Climbing%20Algorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hill Climbing Algorithm on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpersonal-blog-9z4kmk1ax-galelmalah.vercel.app%2fposts%2fadvent-of-code%2f2022%2fday-12%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hill Climbing Algorithm on whatsapp" href="https://api.whatsapp.com/send?text=Hill%20Climbing%20Algorithm%20-%20https%3a%2f%2fpersonal-blog-9z4kmk1ax-galelmalah.vercel.app%2fposts%2fadvent-of-code%2f2022%2fday-12%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hill Climbing Algorithm on telegram" href="https://telegram.me/share/url?text=Hill%20Climbing%20Algorithm&url=https%3a%2f%2fpersonal-blog-9z4kmk1ax-galelmalah.vercel.app%2fposts%2fadvent-of-code%2f2022%2fday-12%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://personal-blog-9z4kmk1ax-galelmalah.vercel.app/>Gal.E</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>